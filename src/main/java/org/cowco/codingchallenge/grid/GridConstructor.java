package org.cowco.codingchallenge.grid;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.cowco.codingchallenge.dictionary.LanguageDictionary;

/**
 * This class handles creating the actual grid of words.
 */
public class GridConstructor {
    private static final Logger LOGGER = LogManager.getLogger(LanguageDictionary.class);

    private LanguageDictionary dict;
    private int gridDim;
    private List<String> gridContents = new ArrayList<>();
    private Map<String, Set<String>> prefixes = new HashMap<>();

    public GridConstructor(LanguageDictionary dict) {
        this.dict = dict;
    }

    /**
     * This method builds the actual word square.
     * TODO Perhaps we want to generate *all* valid word squares, rather than simply the first one we come across?
     * @param dimension The generated grid is square of dimension n
     * @param letters The available letters to use
     */
    public void constructGrid(int dimension, String letters) {
        if (letters.length() != dimension * dimension) {
            LOGGER.error("Wrong number of letters! There should be " + dimension * dimension + " letters but there are actually " + letters.length());
        } else {
            gridDim = dimension;
            gridContents = new ArrayList<>();
            dict.filterByLength(dimension).filterByLetters(letters);
            
            if (dict.numWords() > 0) {
                dict.getWordStream().forEach(word -> generatePrefixMap(word));
                recursiveGridCreator(0, new ArrayList<>());
                printGrid();
            } else {
                LOGGER.error("No words fit the criteria!");
            }
        }
    }

    /**
     * We utilise the fact that the valid words for the square are determined by the leading letters in the previous words
     * @param word The word to generate prefixes from
     */
    private void generatePrefixMap(String word) {
        for (int i = 0; i < gridDim; i++) {
            String prefix = word.substring(0, i);
            Set<String> validWords = prefixes.getOrDefault(prefix, new HashSet<>());
            validWords.add(word);
            prefixes.put(prefix, validWords);
        }
    }

    /**
     * Recursively generates the grid, by finding permutations of words with the correct prefixes, using the prefix map generated by generatePrefixMap
     * @param gridRow Which row of the grid we are on - determines the length of the prefix to use
     * @param runningGridWords The grid that we are currently building
     */
    private void recursiveGridCreator(int gridRow, List<String> runningGridWords) {
        // Recursion end-condition
        if (gridRow == gridDim) {
            gridContents = new ArrayList<>(runningGridWords);
        } else if (gridContents.size() != gridDim) {
            String currentPrefix = "";
            for (String word : runningGridWords) {
                currentPrefix += word.charAt(gridRow);
            }

            // Current grid is invalid if no words match the prefix
            if (!prefixes.containsKey(currentPrefix)) {
                return;
            }

            for (String prefixedWord : prefixes.get(currentPrefix)) {
                runningGridWords.add(prefixedWord);
                recursiveGridCreator(gridRow + 1, runningGridWords);
                runningGridWords.remove(runningGridWords.size() - 1);
            }
        }
    }

    public final List<String> getGrid() {
        return gridContents;
    }

    private void printGrid() {
        LOGGER.info("The grid is: ");
        for (String word : gridContents) {
            LOGGER.info(word);
        }
    }
}
